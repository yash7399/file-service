private void copyFile(
        ChannelSftp sftp,
        String connectionCode,
        DiskShare share,
        String smbShareName,
        String fileName,
        String sftpFilePath,
        String destinationPath,
        int time,
        String department,
        Map<String, List<String>> missingFiles,
        Map<String, List<String>> transferedFiles)
        throws SftpException, IOException {

    // =========================
    // Create folders (same logic)
    // =========================
    String[] folders = destinationPath.split("/");
    String currentPath = "";

    for (String folder : folders) {
        currentPath = currentPath.isEmpty() ? folder : currentPath + "/" + folder;
        try {
            share.mkdir(currentPath);
        } catch (SMBApiException e) {
            if (e.getStatus() != NtStatus.STATUS_OBJECT_NAME_COLLISION) {
                log.info("Error creating folder " + e);
            }
        }
    }

    // =========================
    // STREAMING TRANSFER
    // =========================

    final int BUFFER_SIZE = 4 * 1024 * 1024; // ‚≠ê 4MB sweet spot

    try {

        log.info("Starting streaming transfer: " + fileName);

        try (
            InputStream sftpInput = sftp.get(sftpFilePath);

            com.hierynomus.smbj.share.File smbFile =
                share.openFile(
                    destinationPath + "\\" + fileName,
                    EnumSet.of(AccessMask.FILE_WRITE_DATA),
                    EnumSet.of(FileAttributes.FILE_ATTRIBUTE_NORMAL),
                    EnumSet.noneOf(SMB2ShareAccess.class),
                    SMB2CreateDisposition.FILE_OVERWRITE_IF,
                    null
                );

            OutputStream smbOutput = smbFile.getOutputStream()
        ) {

            byte[] buffer = new byte[BUFFER_SIZE];

            int read;

            long total = 0;
            long start = System.currentTimeMillis();

            // üî• DIRECT PIPE (download + upload simultaneously)
            while ((read = sftpInput.read(buffer)) != -1) {
                smbOutput.write(buffer, 0, read);
                total += read;
            }

            smbOutput.flush();

            long end = System.currentTimeMillis();

            log.info("Transferred " + fileName +
                    " size=" + (total / (1024 * 1024)) + " MB" +
                    " time=" + ((end - start) / 1000.0) + " sec");

            System.out.println("Streaming completed: " + fileName);
        }

    }
    catch (SftpException e) {

        if (e.id == ChannelSftp.SSH_FX_PERMISSION_DENIED) {
            log.error("Permission denied: " + e.getMessage());
            throw e;
        }
        else {
            log.error(e);
            sftp = SFTPConnection.connect(connectionCode);
            Session smb = NASConnection.connect();
            share = (DiskShare) smb.connectShare(smbShareName);
        }

    }
    catch (IOException e) {

        String msg = e.getMessage() != null ? e.getMessage().toLowerCase() : "";

        if (msg.contains("access is denied")
                || msg.contains("permission denied")
                || msg.contains("being used")) {

            log.error("Transfer failed: " + e.getMessage());
            throw e;
        }
        else if (msg.contains("disk full")
                || msg.contains("no space left")
                || msg.contains("not enough space")) {

            log.error("Disk full");
            emails.connectionIssue();
        }
        else {
            log.error(e);
            sftp = SFTPConnection.connect(connectionCode);
            Session smb = NASConnection.connect();
            share = (DiskShare) smb.connectShare(smbShareName);
        }
    }
    catch (Exception e) {
        log.error(e);
        emails.connectionIssue();
    }
}